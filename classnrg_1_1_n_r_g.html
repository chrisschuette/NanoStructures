<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NanoStructures: nrg::NRG Class Reference</title>
<script type="text/javascript" src="bower_components/jquery/dist/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
<script type="text/javascript" src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
<!-- Raleway font -->
<link rel='stylesheet' id='google_fonts-css'  href='http://fonts.googleapis.com/css?family=Megrim|Raleway|Open+Sans:400,400italic,700,700italic' type='text/css' media='all' />
<!-- Font Awesome -->
<link href="font-awesome/css/font-awesome.min.css" rel="stylesheet" />
<!-- MathJax.js --> 
<!-- Single dollar signs as math-mode delimiters --> 
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
inlineMath: [['$','$'], ['\\(','\\)']]
},
TeX: {
Macros: {
RR: "{\\bf  R}",
vect: ["\\mathbf{#1}",1],
ket: ["\\left| #1 \\right\\rangle",1],
bra: ["\\left< #1 \\right|",1],
avg: ["\\left\\langle #1 \\right\\rangle",1]
}
}
});
</script> 
<script type="text/javascript" src="MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> 
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div class="container">
<div class="backplane">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NanoStructures
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">DMFT solver for layered, strongly correlated nanostructures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nrg</b></li><li class="navelem"><a class="el" href="classnrg_1_1_n_r_g.html">NRG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classnrg_1_1_n_r_g-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nrg::NRG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Density matrix implementation of the numerical renormalization group.  
 <a href="classnrg_1_1_n_r_g.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nrg_8h_source.html">nrg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f3ab075bae106cc9d769b909bcd3b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a4f3ab075bae106cc9d769b909bcd3b23">NRG</a> (<a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> &amp;chainProvider, <a class="el" href="classnrg_1_1_broadener.html">Broadener</a> &amp;broadener)</td></tr>
<tr class="memdesc:a4f3ab075bae106cc9d769b909bcd3b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs an <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> algorithm instance The Wilson chain is provided by an implementation of the <a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> interface. The <a class="el" href="classnrg_1_1_broadener.html">Broadener</a> is used after diagonalization of the chain and calculation of the density matrix to broaden the representation of various correlation functions as a discrete set of delta peaks into continous functions.  <a href="#a4f3ab075bae106cc9d769b909bcd3b23">More...</a><br/></td></tr>
<tr class="separator:a4f3ab075bae106cc9d769b909bcd3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374be5926ec514d39e3027a9369b9662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374be5926ec514d39e3027a9369b9662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a374be5926ec514d39e3027a9369b9662">~NRG</a> ()</td></tr>
<tr class="memdesc:a374be5926ec514d39e3027a9369b9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructs the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> algorithm object and frees all previously allocated memory. <br/></td></tr>
<tr class="separator:a374be5926ec514d39e3027a9369b9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d553389916019021754b3a46f228dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a8d553389916019021754b3a46f228dd5">configure</a> (<a class="el" href="classconfig_1_1_configuration.html">config::Configuration</a> &amp;configuration)</td></tr>
<tr class="memdesc:a8d553389916019021754b3a46f228dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> instance with information in the configuration object.  <a href="#a8d553389916019021754b3a46f228dd5">More...</a><br/></td></tr>
<tr class="separator:a8d553389916019021754b3a46f228dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae076986d428d7d680c467a646dfb820a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ae076986d428d7d680c467a646dfb820a">getU</a> () const </td></tr>
<tr class="memdesc:ae076986d428d7d680c467a646dfb820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves the strength of the on-site impurity interaction U  <a href="#ae076986d428d7d680c467a646dfb820a">More...</a><br/></td></tr>
<tr class="separator:ae076986d428d7d680c467a646dfb820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aa5d54ee31cd893c461bcd620a8e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a49aa5d54ee31cd893c461bcd620a8e0d">setU</a> (double U)</td></tr>
<tr class="memdesc:a49aa5d54ee31cd893c461bcd620a8e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the strength of the on-site impurity interaction U  <a href="#a49aa5d54ee31cd893c461bcd620a8e0d">More...</a><br/></td></tr>
<tr class="separator:a49aa5d54ee31cd893c461bcd620a8e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b862f7d9fe2f96b61f8f52daf67924"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ad0b862f7d9fe2f96b61f8f52daf67924">getEpsF</a> () const </td></tr>
<tr class="memdesc:ad0b862f7d9fe2f96b61f8f52daf67924"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves the on-site impurity energy \(\epsilon_f\)  <a href="#ad0b862f7d9fe2f96b61f8f52daf67924">More...</a><br/></td></tr>
<tr class="separator:ad0b862f7d9fe2f96b61f8f52daf67924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8461747f2e58ace9b14e6966bb6800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a4c8461747f2e58ace9b14e6966bb6800">setEpsF</a> (double epsF)</td></tr>
<tr class="memdesc:a4c8461747f2e58ace9b14e6966bb6800"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the on-site impurity energy \(\epsilon_f\)  <a href="#a4c8461747f2e58ace9b14e6966bb6800">More...</a><br/></td></tr>
<tr class="separator:a4c8461747f2e58ace9b14e6966bb6800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2da4871033be406050c5af5d7cd2dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a1d2da4871033be406050c5af5d7cd2dd">getTemperature</a> () const </td></tr>
<tr class="memdesc:a1d2da4871033be406050c5af5d7cd2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves the system temperature T  <a href="#a1d2da4871033be406050c5af5d7cd2dd">More...</a><br/></td></tr>
<tr class="separator:a1d2da4871033be406050c5af5d7cd2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a18a1d48d935fe2f226fe6538a8814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ab4a18a1d48d935fe2f226fe6538a8814">setTemperature</a> (double T)</td></tr>
<tr class="memdesc:ab4a18a1d48d935fe2f226fe6538a8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the system temperature T  <a href="#ab4a18a1d48d935fe2f226fe6538a8814">More...</a><br/></td></tr>
<tr class="separator:ab4a18a1d48d935fe2f226fe6538a8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e0aac1a11a4901db957b979c43b9ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#af4e0aac1a11a4901db957b979c43b9ce">getClusterEnergy</a> () const </td></tr>
<tr class="memdesc:af4e0aac1a11a4901db957b979c43b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the cluster energy.  <a href="#af4e0aac1a11a4901db957b979c43b9ce">More...</a><br/></td></tr>
<tr class="separator:af4e0aac1a11a4901db957b979c43b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3acc6323287e027b8bef2dd997143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ae1a3acc6323287e027b8bef2dd997143">setClusterEnergy</a> (double clusterEnergy)</td></tr>
<tr class="memdesc:ae1a3acc6323287e027b8bef2dd997143"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the cluster energy to the indicated value. see <a class="el" href="classnrg_1_1_n_r_g.html#af4e0aac1a11a4901db957b979c43b9ce" title="returns the cluster energy. ">getClusterEnergy()</a>.  <a href="#ae1a3acc6323287e027b8bef2dd997143">More...</a><br/></td></tr>
<tr class="separator:ae1a3acc6323287e027b8bef2dd997143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fd05573490a1116548cfc657094e61"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a11fd05573490a1116548cfc657094e61">getEnergyCutOff</a> () const </td></tr>
<tr class="memdesc:a11fd05573490a1116548cfc657094e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the high energy cut-off for state truncation  <a href="#a11fd05573490a1116548cfc657094e61">More...</a><br/></td></tr>
<tr class="separator:a11fd05573490a1116548cfc657094e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf915bc58252a82cf75bc9a0a66671b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#aebf915bc58252a82cf75bc9a0a66671b">setEnergyCutOff</a> (double energyCutOff)</td></tr>
<tr class="memdesc:aebf915bc58252a82cf75bc9a0a66671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the high energy cut-off for state truncation  <a href="#aebf915bc58252a82cf75bc9a0a66671b">More...</a><br/></td></tr>
<tr class="separator:aebf915bc58252a82cf75bc9a0a66671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24986007a997c14f3f5317d53d6694e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a24986007a997c14f3f5317d53d6694e5">getMaxHilbertSpaceDimension</a> ()</td></tr>
<tr class="memdesc:a24986007a997c14f3f5317d53d6694e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum allowed size of the HilberSpace. See <a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308" title="marks all eigenstates above a cut-off energy  as discarded. ">truncateStates(int n)</a>.  <a href="#a24986007a997c14f3f5317d53d6694e5">More...</a><br/></td></tr>
<tr class="separator:a24986007a997c14f3f5317d53d6694e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d674168a503bb87c5f96facffeed312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a3d674168a503bb87c5f96facffeed312">setMaxHilbertSpaceDimension</a> (int maxHSdimension)</td></tr>
<tr class="memdesc:a3d674168a503bb87c5f96facffeed312"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the maximum allowed size of the HilberSpace. See <a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308" title="marks all eigenstates above a cut-off energy  as discarded. ">truncateStates(int n)</a>.  <a href="#a3d674168a503bb87c5f96facffeed312">More...</a><br/></td></tr>
<tr class="separator:a3d674168a503bb87c5f96facffeed312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d861665f0ac0e3c0bf356cc08cf3b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a16d861665f0ac0e3c0bf356cc08cf3b2">getMaxIterations</a> ()</td></tr>
<tr class="separator:a16d861665f0ac0e3c0bf356cc08cf3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986c109b4276b419f4e8de09b0295e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a986c109b4276b419f4e8de09b0295e3e">setMaxIterations</a> (int maxIterations)</td></tr>
<tr class="separator:a986c109b4276b419f4e8de09b0295e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f798bf64f770334c1b62587cdf59663"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a0f798bf64f770334c1b62587cdf59663">getOccupationUp</a> ()</td></tr>
<tr class="memdesc:a0f798bf64f770334c1b62587cdf59663"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the exp. value for spin- \(\uparrow\) electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int n)</a>.  <a href="#a0f798bf64f770334c1b62587cdf59663">More...</a><br/></td></tr>
<tr class="separator:a0f798bf64f770334c1b62587cdf59663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048acdb83a27cfe673a82a6a53897f2c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a048acdb83a27cfe673a82a6a53897f2c">getOccupationDown</a> ()</td></tr>
<tr class="memdesc:a048acdb83a27cfe673a82a6a53897f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the exp. value for spin- \(\downarrow\) electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8" title="see createPolesG_Up(int iteration). This is the spin-  version. ">createPolesG_Down(int n)</a>.  <a href="#a048acdb83a27cfe673a82a6a53897f2c">More...</a><br/></td></tr>
<tr class="separator:a048acdb83a27cfe673a82a6a53897f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d28e59b88fd98e74ff30b0eed34a564"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a6d28e59b88fd98e74ff30b0eed34a564">getOccupation</a> ()</td></tr>
<tr class="memdesc:a6d28e59b88fd98e74ff30b0eed34a564"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the exp. value for electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int n)</a> and <a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8" title="see createPolesG_Up(int iteration). This is the spin-  version. ">createPolesG_Down(int n)</a>.  <a href="#a6d28e59b88fd98e74ff30b0eed34a564">More...</a><br/></td></tr>
<tr class="separator:a6d28e59b88fd98e74ff30b0eed34a564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc052b754ed41227910a2e963346f55"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#acdc052b754ed41227910a2e963346f55">getMagnetization</a> ()</td></tr>
<tr class="memdesc:acdc052b754ed41227910a2e963346f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the exp. value for the magnetization  <a href="#acdc052b754ed41227910a2e963346f55">More...</a><br/></td></tr>
<tr class="separator:acdc052b754ed41227910a2e963346f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2761a143fc6a1cf385b91ad95453409a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a2761a143fc6a1cf385b91ad95453409a">init</a> ()</td></tr>
<tr class="memdesc:a2761a143fc6a1cf385b91ad95453409a"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepares the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> instance for the iterative diagonalization.  <a href="#a2761a143fc6a1cf385b91ad95453409a">More...</a><br/></td></tr>
<tr class="separator:a2761a143fc6a1cf385b91ad95453409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360c9dc565beed2c2e741eceb7696036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a360c9dc565beed2c2e741eceb7696036">setupInitialState</a> ()</td></tr>
<tr class="memdesc:a360c9dc565beed2c2e741eceb7696036"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes the impurity Hamiltonian \(H_0\).  <a href="#a360c9dc565beed2c2e741eceb7696036">More...</a><br/></td></tr>
<tr class="separator:a360c9dc565beed2c2e741eceb7696036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61869162fe17cdf5cf34857b9abd132e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a61869162fe17cdf5cf34857b9abd132e">setupHamiltonian</a> (int iteration)</td></tr>
<tr class="memdesc:a61869162fe17cdf5cf34857b9abd132e"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterates over all possible quantum number Q and Sz for iteration N and constructs the Hamiltonian for the corresponding <a class="el" href="classnrg_1_1_hilbert_sub_space.html" title="HilbertSubSpace: Hilbert subspace for charge quantum number Q and spin Sz. This class contains the ei...">HilbertSubSpace</a>.  <a href="#a61869162fe17cdf5cf34857b9abd132e">More...</a><br/></td></tr>
<tr class="separator:a61869162fe17cdf5cf34857b9abd132e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430ab28bf443456a5f61e488305eb308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308">truncateStates</a> (int iteration)</td></tr>
<tr class="memdesc:a430ab28bf443456a5f61e488305eb308"><td class="mdescLeft">&#160;</td><td class="mdescRight">marks all eigenstates above a cut-off energy \(E_c\) as discarded.  <a href="#a430ab28bf443456a5f61e488305eb308">More...</a><br/></td></tr>
<tr class="separator:a430ab28bf443456a5f61e488305eb308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a868ffea9b163edd3d067d63952d2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a3a868ffea9b163edd3d067d63952d2ad">propagateLocalMatrixElementUp</a> (int iteration)</td></tr>
<tr class="memdesc:a3a868ffea9b163edd3d067d63952d2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the local impurity matrix elements or spin- \(\uparrow\) for a given iteration.  <a href="#a3a868ffea9b163edd3d067d63952d2ad">More...</a><br/></td></tr>
<tr class="separator:a3a868ffea9b163edd3d067d63952d2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4975dc830c8f9c38c66dc0e877cd3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a7c4975dc830c8f9c38c66dc0e877cd3a">propagateLocalMatrixElementDown</a> (int iteration)</td></tr>
<tr class="memdesc:a7c4975dc830c8f9c38c66dc0e877cd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classnrg_1_1_n_r_g.html#a3a868ffea9b163edd3d067d63952d2ad" title="calculates the local impurity matrix elements or spin-  for a given iteration. ">propagateLocalMatrixElementUp(int iteration)</a>. This is the spin- \(\downarrow\) version.  <a href="#a7c4975dc830c8f9c38c66dc0e877cd3a">More...</a><br/></td></tr>
<tr class="separator:a7c4975dc830c8f9c38c66dc0e877cd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057fbf412fc125417bf8788ab0a6ef9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a057fbf412fc125417bf8788ab0a6ef9b">propagateLocalMatrixElementUp2</a> (int iteration)</td></tr>
<tr class="memdesc:a057fbf412fc125417bf8788ab0a6ef9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates other local impurity matrix elements or spin- \(\uparrow\) for a given iteration.  <a href="#a057fbf412fc125417bf8788ab0a6ef9b">More...</a><br/></td></tr>
<tr class="separator:a057fbf412fc125417bf8788ab0a6ef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f818bc65b105af60350aba50367b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ac4f818bc65b105af60350aba50367b84">propagateLocalMatrixElementDown2</a> (int iteration)</td></tr>
<tr class="memdesc:ac4f818bc65b105af60350aba50367b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classnrg_1_1_n_r_g.html#a057fbf412fc125417bf8788ab0a6ef9b" title="calculates other local impurity matrix elements or spin-  for a given iteration. ">propagateLocalMatrixElementUp2(int iteration)</a>. This is the spin- \(\downarrow\) version.  <a href="#ac4f818bc65b105af60350aba50367b84">More...</a><br/></td></tr>
<tr class="separator:ac4f818bc65b105af60350aba50367b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d8a5fd44271bd1a246c65b86ee7f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a38d8a5fd44271bd1a246c65b86ee7f82">propagateChainOperatorElementsUp</a> (int iteration)</td></tr>
<tr class="memdesc:a38d8a5fd44271bd1a246c65b86ee7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the chain matrix elements for spin- \(\uparrow\) for a given iteration.  <a href="#a38d8a5fd44271bd1a246c65b86ee7f82">More...</a><br/></td></tr>
<tr class="separator:a38d8a5fd44271bd1a246c65b86ee7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ae89acb88e93156c845c5ecea4612e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a99ae89acb88e93156c845c5ecea4612e">propagateChainOperatorElementsDown</a> (int iteration)</td></tr>
<tr class="memdesc:a99ae89acb88e93156c845c5ecea4612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classnrg_1_1_n_r_g.html#a38d8a5fd44271bd1a246c65b86ee7f82" title="calculates the chain matrix elements for spin-  for a given iteration. ">propagateChainOperatorElementsUp(int iteration)</a>. This is the spin- \(\downarrow\) version.  <a href="#a99ae89acb88e93156c845c5ecea4612e">More...</a><br/></td></tr>
<tr class="separator:a99ae89acb88e93156c845c5ecea4612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e17ab2a4393f21a6863b714e3dc0e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85">createPolesG_Up</a> (int iteration)</td></tr>
<tr class="memdesc:a3e17ab2a4393f21a6863b714e3dc0e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates delta peaks for the spin- \(\uparrow\) impurity Green's function.  <a href="#a3e17ab2a4393f21a6863b714e3dc0e85">More...</a><br/></td></tr>
<tr class="separator:a3e17ab2a4393f21a6863b714e3dc0e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea85b0f075bafa8d67a7a1a5ac670e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8">createPolesG_Down</a> (int iteration)</td></tr>
<tr class="memdesc:a4ea85b0f075bafa8d67a7a1a5ac670e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int iteration)</a>. This is the spin- \(\downarrow\) version.  <a href="#a4ea85b0f075bafa8d67a7a1a5ac670e8">More...</a><br/></td></tr>
<tr class="separator:a4ea85b0f075bafa8d67a7a1a5ac670e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6581be9331b44238dd2b4f164de76d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a6581be9331b44238dd2b4f164de76d3d">createPolesF_Up</a> (int iteration)</td></tr>
<tr class="memdesc:a6581be9331b44238dd2b4f164de76d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates delta peaks for the spin- \(\uparrow\) impurity correlator used in the self-energy trick.  <a href="#a6581be9331b44238dd2b4f164de76d3d">More...</a><br/></td></tr>
<tr class="separator:a6581be9331b44238dd2b4f164de76d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0c0ee4eeeb9e97ecf052be4ffa3d82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#aba0c0ee4eeeb9e97ecf052be4ffa3d82">createPolesF_Down</a> (int iteration)</td></tr>
<tr class="memdesc:aba0c0ee4eeeb9e97ecf052be4ffa3d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classnrg_1_1_n_r_g.html#aba0c0ee4eeeb9e97ecf052be4ffa3d82" title="see createPolesF_Down(int iteration). This is the spin-  version. ">createPolesF_Down(int iteration)</a>. This is the spin- \(\downarrow\) version.  <a href="#aba0c0ee4eeeb9e97ecf052be4ffa3d82">More...</a><br/></td></tr>
<tr class="separator:aba0c0ee4eeeb9e97ecf052be4ffa3d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a2a7395b2f9a5b6884b8c44f969d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a54a2a7395b2f9a5b6884b8c44f969d13">solve</a> (bool silent=false)</td></tr>
<tr class="memdesc:a54a2a7395b2f9a5b6884b8c44f969d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves the impurity problem.  <a href="#a54a2a7395b2f9a5b6884b8c44f969d13">More...</a><br/></td></tr>
<tr class="separator:a54a2a7395b2f9a5b6884b8c44f969d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d7e07864134a128a4a0628531ecdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#af9d7e07864134a128a4a0628531ecdcf">solve_symmetric_SZ</a> (bool silent=false)</td></tr>
<tr class="memdesc:af9d7e07864134a128a4a0628531ecdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="classnrg_1_1_n_r_g.html#a54a2a7395b2f9a5b6884b8c44f969d13" title="solves the impurity problem. ">solve(bool silent)</a> for a Wilson chain with Sz symmetry.  <a href="#af9d7e07864134a128a4a0628531ecdcf">More...</a><br/></td></tr>
<tr class="separator:af9d7e07864134a128a4a0628531ecdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35b106fa6225fd965f6b0d77ad4ed14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac35b106fa6225fd965f6b0d77ad4ed14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ac35b106fa6225fd965f6b0d77ad4ed14">builDM</a> ()</td></tr>
<tr class="memdesc:ac35b106fa6225fd965f6b0d77ad4ed14"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a backward run to construct the reduced density matrices <br/></td></tr>
<tr class="separator:ac35b106fa6225fd965f6b0d77ad4ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a64d0594ee027093c02c3741c3ce65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91a64d0594ee027093c02c3741c3ce65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a91a64d0594ee027093c02c3741c3ce65">showInfo</a> ()</td></tr>
<tr class="memdesc:a91a64d0594ee027093c02c3741c3ce65"><td class="mdescLeft">&#160;</td><td class="mdescRight">lists the physical and numerical parameters for the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> instance. Also dumps info about the <a class="el" href="classnrg_1_1_broadener.html">Broadener</a> object. <br/></td></tr>
<tr class="separator:a91a64d0594ee027093c02c3741c3ce65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0aadddc5b894651858861ecc294c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#afa0aadddc5b894651858861ecc294c98">deleteChainOperatorElements</a> (int iteration)</td></tr>
<tr class="memdesc:afa0aadddc5b894651858861ecc294c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes all chain operator matrix elements for the indicated iteration.  <a href="#afa0aadddc5b894651858861ecc294c98">More...</a><br/></td></tr>
<tr class="separator:afa0aadddc5b894651858861ecc294c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d675dae3865b328c582289679f060b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a19d675dae3865b328c582289679f060b">deleteTransformationMatrices</a> (int iteration)</td></tr>
<tr class="memdesc:a19d675dae3865b328c582289679f060b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes all transformation matrices for the indicated iteration.  <a href="#a19d675dae3865b328c582289679f060b">More...</a><br/></td></tr>
<tr class="separator:a19d675dae3865b328c582289679f060b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c5879975d9d739ade31bf646a93e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#ac5c5879975d9d739ade31bf646a93e45">deleteDensityMatrices</a> (int iteration)</td></tr>
<tr class="memdesc:ac5c5879975d9d739ade31bf646a93e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes all chain operator matrix elements for the indicated iteration.  <a href="#ac5c5879975d9d739ade31bf646a93e45">More...</a><br/></td></tr>
<tr class="separator:ac5c5879975d9d739ade31bf646a93e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e6c976eb1c8466ca5278e1c5269fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a67e6c976eb1c8466ca5278e1c5269fe9">deleteImpurityMatrixElements</a> (int iteration)</td></tr>
<tr class="memdesc:a67e6c976eb1c8466ca5278e1c5269fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes all impurity operator matrix elements for the indicated iteration.  <a href="#a67e6c976eb1c8466ca5278e1c5269fe9">More...</a><br/></td></tr>
<tr class="separator:a67e6c976eb1c8466ca5278e1c5269fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc519743d6cdc9924f75329386dd6d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#acc519743d6cdc9924f75329386dd6d00">getSelfEnergy</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;SUp, <a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;SDown)</td></tr>
<tr class="memdesc:acc519743d6cdc9924f75329386dd6d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the impurity selfenergy.  <a href="#acc519743d6cdc9924f75329386dd6d00">More...</a><br/></td></tr>
<tr class="separator:acc519743d6cdc9924f75329386dd6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beee407b6defe0184e8a2244efa1716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a7beee407b6defe0184e8a2244efa1716">getSelfEnergy</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;S)</td></tr>
<tr class="memdesc:a7beee407b6defe0184e8a2244efa1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the impurity selfenergy.  <a href="#a7beee407b6defe0184e8a2244efa1716">More...</a><br/></td></tr>
<tr class="separator:a7beee407b6defe0184e8a2244efa1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593ca3b6cbbdf8580122d4e0ca1e31cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a593ca3b6cbbdf8580122d4e0ca1e31cd">getGreensFunction</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;GUp, <a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;GDown)</td></tr>
<tr class="memdesc:a593ca3b6cbbdf8580122d4e0ca1e31cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the impurity Green's function.  <a href="#a593ca3b6cbbdf8580122d4e0ca1e31cd">More...</a><br/></td></tr>
<tr class="separator:a593ca3b6cbbdf8580122d4e0ca1e31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3444274c059c6882e92b8aa49661075f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a3444274c059c6882e92b8aa49661075f">getGreensFunction</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;G)</td></tr>
<tr class="memdesc:a3444274c059c6882e92b8aa49661075f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Green's function.  <a href="#a3444274c059c6882e92b8aa49661075f">More...</a><br/></td></tr>
<tr class="separator:a3444274c059c6882e92b8aa49661075f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e165c3840b3b0d76c22bf4722dfcfaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a1e165c3840b3b0d76c22bf4722dfcfaf">getFFunction</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;FUp, <a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;FDown)</td></tr>
<tr class="memdesc:a1e165c3840b3b0d76c22bf4722dfcfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the correlator for the self-energy trick  <a href="#a1e165c3840b3b0d76c22bf4722dfcfaf">More...</a><br/></td></tr>
<tr class="separator:a1e165c3840b3b0d76c22bf4722dfcfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9041ea15fe240c1660e2bb7c93980f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrg_1_1_n_r_g.html#a9041ea15fe240c1660e2bb7c93980f54">getFFunction</a> (<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;F)</td></tr>
<tr class="memdesc:a9041ea15fe240c1660e2bb7c93980f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the correlator for the self-energy trick  <a href="#a9041ea15fe240c1660e2bb7c93980f54">More...</a><br/></td></tr>
<tr class="separator:a9041ea15fe240c1660e2bb7c93980f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1b2c89da6dee0c61d4ce01c31755f458"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b2c89da6dee0c61d4ce01c31755f458"></a>
<a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_chainProvider</b></td></tr>
<tr class="separator:a1b2c89da6dee0c61d4ce01c31755f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64435d595579fc0fe292b23eb647b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf64435d595579fc0fe292b23eb647b2"></a>
<a class="el" href="classnrg_1_1_broadener.html">Broadener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_broadener</b></td></tr>
<tr class="separator:adf64435d595579fc0fe292b23eb647b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac693c56fe8a4bae926ed7a8112a7037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac693c56fe8a4bae926ed7a8112a7037"></a>
<a class="el" href="classnrg_1_1_broadener.html">Broadener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_G_Up</b></td></tr>
<tr class="separator:aac693c56fe8a4bae926ed7a8112a7037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9e80d67fdfafb5ca8dbb7930b927af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e9e80d67fdfafb5ca8dbb7930b927af"></a>
<a class="el" href="classnrg_1_1_broadener.html">Broadener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_G_Down</b></td></tr>
<tr class="separator:a5e9e80d67fdfafb5ca8dbb7930b927af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77af2248f8df407680a29b321a6b5e79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77af2248f8df407680a29b321a6b5e79"></a>
<a class="el" href="classnrg_1_1_broadener.html">Broadener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_Up</b></td></tr>
<tr class="separator:a77af2248f8df407680a29b321a6b5e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c7e158cb0f9729820c169c36248b03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22c7e158cb0f9729820c169c36248b03"></a>
<a class="el" href="classnrg_1_1_broadener.html">Broadener</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_Down</b></td></tr>
<tr class="separator:a22c7e158cb0f9729820c169c36248b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133e84b76aab3108d4b3e15f8c41ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa133e84b76aab3108d4b3e15f8c41ab9"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_S_Up</b></td></tr>
<tr class="separator:aa133e84b76aab3108d4b3e15f8c41ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054e593e306aeb3f7857eef5e1c940ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a054e593e306aeb3f7857eef5e1c940ce"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_S_Down</b></td></tr>
<tr class="separator:a054e593e306aeb3f7857eef5e1c940ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae018fbf450d257be315554bf9608699b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae018fbf450d257be315554bf9608699b"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_G_Up</b></td></tr>
<tr class="separator:ae018fbf450d257be315554bf9608699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6824c6123743112c2b48ec1058a57da0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6824c6123743112c2b48ec1058a57da0"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_G_Down</b></td></tr>
<tr class="separator:a6824c6123743112c2b48ec1058a57da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ecf22fb706ea8f1a43c2cfe06031b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959ecf22fb706ea8f1a43c2cfe06031b"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_F_Up</b></td></tr>
<tr class="separator:a959ecf22fb706ea8f1a43c2cfe06031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47aa62eb32237d953dda8fd6e995edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab47aa62eb32237d953dda8fd6e995edc"></a>
<a class="el" href="classmath_1_1_c_function.html">math::CFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_F_Down</b></td></tr>
<tr class="separator:ab47aa62eb32237d953dda8fd6e995edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0e0902b5acd01cece5b7898569f53e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb0e0902b5acd01cece5b7898569f53e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_n_Up</b></td></tr>
<tr class="separator:afb0e0902b5acd01cece5b7898569f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3927fc00d7a48892c3b617c4b743de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3927fc00d7a48892c3b617c4b743de"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_n_Down</b></td></tr>
<tr class="separator:a1e3927fc00d7a48892c3b617c4b743de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18c15bfecbd6c195ff09b9d01329e2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af18c15bfecbd6c195ff09b9d01329e2a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_epsF</b></td></tr>
<tr class="separator:af18c15bfecbd6c195ff09b9d01329e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf1a7fc7142588e3630b038c0291978"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf1a7fc7142588e3630b038c0291978"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_U</b></td></tr>
<tr class="separator:adbf1a7fc7142588e3630b038c0291978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d5c2f9583ffcba8be1e4e877a18c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace4d5c2f9583ffcba8be1e4e877a18c5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_temperature</b></td></tr>
<tr class="separator:ace4d5c2f9583ffcba8be1e4e877a18c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067f62343bbb7ec23d68cf15dcead321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a067f62343bbb7ec23d68cf15dcead321"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxIterations</b></td></tr>
<tr class="separator:a067f62343bbb7ec23d68cf15dcead321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312ad0df86766c8046e18e3af75da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd312ad0df86766c8046e18e3af75da1"></a>
std::mathbfor&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_energies</b></td></tr>
<tr class="separator:abd312ad0df86766c8046e18e3af75da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071830079d2831e5990343547169d1e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a071830079d2831e5990343547169d1e5"></a>
<a class="el" href="classnrg_1_1_hilbert_space_table.html">HilbertSpaceTable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_hilbertSpaces</b></td></tr>
<tr class="separator:a071830079d2831e5990343547169d1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6635426463adc6b92fb95777f8240a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a6635426463adc6b92fb95777f8240a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_clusterEnergy</b></td></tr>
<tr class="separator:a0a6635426463adc6b92fb95777f8240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b20b01b1812725642f4471e0a51ec9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78b20b01b1812725642f4471e0a51ec9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_energyCutOff</b></td></tr>
<tr class="separator:a78b20b01b1812725642f4471e0a51ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a0f7636abc66d1879fbe989810683f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a0f7636abc66d1879fbe989810683f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxHSdimension</b></td></tr>
<tr class="separator:aa0a0f7636abc66d1879fbe989810683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d8882375d301d517cd16ada7a9f53a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79d8882375d301d517cd16ada7a9f53a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_nFirstTruncated</b></td></tr>
<tr class="separator:a79d8882375d301d517cd16ada7a9f53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf841c959af8e4b5355107e180a7aaf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf841c959af8e4b5355107e180a7aaf1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>signLME</b> [4]</td></tr>
<tr class="separator:adf841c959af8e4b5355107e180a7aaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da529df6b831647daeb4a47c149ac0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da529df6b831647daeb4a47c149ac0a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dQ</b> [4]</td></tr>
<tr class="separator:a8da529df6b831647daeb4a47c149ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b265d892a44603ee796392f9405cc7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b265d892a44603ee796392f9405cc7d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dSz</b> [4]</td></tr>
<tr class="separator:a2b265d892a44603ee796392f9405cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Density matrix implementation of the numerical renormalization group. </p>
<h1>The Numerical Renormalization Group </h1>
<p>The Numerical Renormalization Group (<a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a>) is one of the standard tools to study correlation effects in quantum impurity models. Here a small interacting subsystem with a small number of degrees of freedom (the impurity) is coupled to a bath of fermions. No restriction exists as to the structure of the impurity subsystem. The bath however must consist of non-interacting fermions.</p>
<h3>Logarithmic discretization</h3>
<p>At the heart of the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> lies a logarithmic discretization of the continous conduction electron band. The continuum density of states \(\rho(\epsilon)\) is approximated by a discrete set of delta poles. By introducing a discretisation parameter \(\Lambda\) Wilson divided the normalised energy range \([-1,1]\) into \(2n\) intervals where the \(n\)th interval (for positive \(\epsilon\)) extends from \(\Lambda^{-(n+1)}\) to \(\Lambda^n\). The logarithmic discretisation separates the electron energies into different orders of magnitude where energies close to the Fermi level \(k_B T \ll D\) with \(D\) the bandwidth, which determine the low temperature properties, are well sampled.</p>
<h3>Mapping onto a chain</h3>
<p>In order to solve the discretized Hamiltonian iteratively one introduces a set of operators \(f_{n\sigma}\) with \(n&gt;0\) in such a way that they exhibit only nearest neighbour coupling. The Hamiltonian assumes the structure of a hopping Hamiltonian on a semi-infinite chain, which is often referred to as the <em>Wilson chain</em>.</p>
<h3>Iterative diagonalization</h3>
<p>The transformations performed so far have rendered a form of the Hamiltonian which is amendable to an iterative diagonalisation procedure. Now one defines a sequence of Hamiltonians \(H_N\) with \(N \geq 0\). The full discrete Hamiltonian is recovered in the limit \(N\to\infty\) as</p>
<p>\( \begin{equation} H = \lim_{N\to\infty} \frac{1}{2} (1+\Lambda^{-1}) D \Lambda^{-(N-1)/2}H_N \end{equation} \)</p>
<p>Two successive Hamiltonians in the series are connected by the recursion relation</p>
<p>\( \begin{equation} H_{N+1} = \Lambda^{1/2} H_N + t_N ( f^\dagger_{N \sigma} f_{N+1\sigma} + f^\dagger _{N+1\sigma} f_{N\sigma} ) \end{equation} \)</p>
<p>with the initial Hamiltonian in the series containing the impurity itself given by</p>
<p>\( \begin{equation} H_0 = \Lambda^{-\frac{1}{2}} \left[ \tilde{\delta_d} c^\dagger_{d \sigma} c_{d \sigma} + \tilde{\Gamma}^{1/2} ( f^\dagger_{0 \sigma} c_{d\sigma} + \text{h.c.} ) + \tilde{U} ( c_{d \sigma}^\dagger c_{d \sigma} - 1)^2\right] \end{equation} \)</p>
<p>In this form the single impurity Anderson model can be efficiently solved on a computer by taking advantage of the renormalisation group character of the above description. One starts with a diagonalisation of \(H_0\) which can be easily accomplished numerically. Assuming that we have diagonalised a Wilson chain of length \(m\) and that the eigenstates are given by \(|\mathbf r;m\rangle\) we construct a product basis for the Wilson chain of length \(m+1\) by</p>
<p>\( \begin{equation} |(\mathbf r,\alpha_{m+1});m+1 \rangle = |\mathbf r; m \rangle \otimes |\alpha_{m+1}\rangle \end{equation} \)</p>
<p>where \(|\alpha_{m+1}\rangle\) are the eigenstates of the decoupled site \(|\alpha_{m+1}\rangle=\{ |\rangle,|\uparrow\rangle,|\downarrow\rangle,| \uparrow \downarrow \rangle \}\). The matrix elements of the Hamiltonian for the Wilson chain of length \(m+1\) for this product basis are given by</p>
<p>\( \begin{align} \langle(\mathbf r&#39;,\alpha&#39;_{m+1}); m+1|&amp;H_{m+1} |(\mathbf r,\alpha_{m+1}); m+1\rangle = \Lambda^{1/2} E_{\mathbf r,m} \delta_{\mathbf r \mathbf r&#39;} \delta_{\alpha \alpha&#39;} \nonumber \\ &amp;+\left( \langle \mathbf r&#39;; m |f^\dagger_{m\sigma} |\mathbf r;m \rangle \langle \alpha&#39; | f_{m+1\alpha} |\alpha \rangle + \langle \mathbf r&#39;; m | f_{m\sigma} |\mathbf r;m \rangle \langle\alpha&#39;| f^\dagger_{m+1\alpha} |\alpha\rangle\right) \end{align} \)</p>
<p>The eigenvalue problem for the chain of length \(m+1\) can therefore be solved numerically using only a knowledge of the eigenspectrum of the chain of length \(m\) and the matrix elements of the operators \(f_{m\sigma}^\dagger\). Diagonalising the Hamiltonian \(H_{m+1}\), set up in the above product basis, can be described by a unitary transformation</p>
<p>\( \begin{equation} |\mathbf r&#39;; m+1 \rangle = \sum_{\alpha_{m+1}, \mathbf r} U^{\alpha_{m+1}}_{\mathbf r&#39;, \mathbf r} |\mathbf r;m\rangle \otimes |\alpha_{m+1}\rangle \end{equation} \)</p>
<p>where \(|\mathbf r&#39;; m+1 \rangle\) denotes the new eigenbasis of the Hamiltonian \(H_{m+1}\).</p>
<div class="image">
<img src="truncation.png" alt="truncation.png"/>
<div class="caption">
Illustration of the truncation procedure. The</div></div>
<p> iterative diagonalisation splits each energy level into 4 levels upon the addition of another chain element. In this schematic picture however each energy level is split into only two levels in order not to make the illustration to cluttered. Due to the exponential decrease in the couplings it is save to truncate the high energy states without altering the spectrum of the low energy states. The truncated states are marked red."</p>
<h2>References </h2>
<ul>
<li><a href="http://journals.aps.org/rmp/abstract/10.1103/RevModPhys.80.395">NRG review article by R. Bulla et al.</a></li>
<li><a href="http://journals.aps.org/prb/abstract/10.1103/PhysRevB.21.1003">Renormalization-group approach to the Anderson model by H. R. Krishna-murthy, J. W. Wilkins, and K. G. Wilson</a> </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4f3ab075bae106cc9d769b909bcd3b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nrg::NRG::NRG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>chainProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnrg_1_1_broadener.html">Broadener</a> &amp;&#160;</td>
          <td class="paramname"><em>broadener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> algorithm instance The Wilson chain is provided by an implementation of the <a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> interface. The <a class="el" href="classnrg_1_1_broadener.html">Broadener</a> is used after diagonalization of the chain and calculation of the density matrix to broaden the representation of various correlation functions as a discrete set of delta peaks into continous functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chainProvider</td><td>implementation of the <a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> interface; supplies the Wilson chain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadener</td><td>implementation of the <a class="el" href="classnrg_1_1_broadener.html">Broadener</a> interface; broadens the discrete set of delta peaks of the correlation functions into continous functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8d553389916019021754b3a46f228dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconfig_1_1_configuration.html">config::Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>configures the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> instance with information in the configuration object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configuration</td><td>a configuration object which can be queried for various numerical and physical parameters concerning the impurity problem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba0c0ee4eeeb9e97ecf052be4ffa3d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::createPolesF_Down </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classnrg_1_1_n_r_g.html#aba0c0ee4eeeb9e97ecf052be4ffa3d82" title="see createPolesF_Down(int iteration). This is the spin-  version. ">createPolesF_Down(int iteration)</a>. This is the spin- \(\downarrow\) version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6581be9331b44238dd2b4f164de76d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::createPolesF_Up </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates delta peaks for the spin- \(\uparrow\) impurity correlator used in the self-energy trick. </p>
<p>This function uses the reduced density matrix and the impurity operator matrix elements to calculate delta peaks of the Lehmann representation of the spin- \(\uparrow\) correlator for the given iteration used in the self-energy trick.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ea85b0f075bafa8d67a7a1a5ac670e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::createPolesG_Down </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int iteration)</a>. This is the spin- \(\downarrow\) version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e17ab2a4393f21a6863b714e3dc0e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::createPolesG_Up </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates delta peaks for the spin- \(\uparrow\) impurity Green's function. </p>
<p>This function uses the reduced density matrix and the impurity operator matrix elements to calculate delta peaks of the Lehmann representation of the spin- \(\uparrow\) impurity Green's function for the given iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa0aadddc5b894651858861ecc294c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::deleteChainOperatorElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all chain operator matrix elements for the indicated iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c5879975d9d739ade31bf646a93e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::deleteDensityMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all chain operator matrix elements for the indicated iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67e6c976eb1c8466ca5278e1c5269fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::deleteImpurityMatrixElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all impurity operator matrix elements for the indicated iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19d675dae3865b328c582289679f060b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::deleteTransformationMatrices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all transformation matrices for the indicated iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4e0aac1a11a4901db957b979c43b9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getClusterEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the cluster energy. </p>
<p>Symmetries create degeneracies in the spectrum of eigenstates. Due to numerical noise these states can energetically drift apart by tiny amounts. It is generally not a good idea to cut-off within a multiplet (or "cluster"). It is ensured that no cut is made in between two energy levels less than a certain energy difference apart. This function returns this energy difference.</p>
<dl class="section return"><dt>Returns</dt><dd>cluster energy </dd></dl>

</div>
</div>
<a class="anchor" id="a11fd05573490a1116548cfc657094e61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getEnergyCutOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the high energy cut-off for state truncation </p>
<dl class="section return"><dt>Returns</dt><dd>high-energy cut-off </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b862f7d9fe2f96b61f8f52daf67924"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getEpsF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieves the on-site impurity energy \(\epsilon_f\) </p>
<dl class="section return"><dt>Returns</dt><dd>epsF on-site energy \(\epsilon_f\) </dd></dl>

</div>
</div>
<a class="anchor" id="a1e165c3840b3b0d76c22bf4722dfcfaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getFFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>FUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>FDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the correlator for the self-energy trick </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FUp</td><td>reference to spin- \(\uparrow\) correlator </td></tr>
    <tr><td class="paramname">FDown</td><td>reference to spin- \(\downarrow\) correlator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9041ea15fe240c1660e2bb7c93980f54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getFFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the correlator for the self-energy trick </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>reference to spin- \(\uparrow\) correlator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a593ca3b6cbbdf8580122d4e0ca1e31cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getGreensFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>GUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>GDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the impurity Green's function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">GUp</td><td>reference to spin- \(\uparrow\) Green's function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GDown</td><td>reference to spin- \(\downarrow\) Green's function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3444274c059c6882e92b8aa49661075f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getGreensFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the Green's function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>reference to spin- \(\uparrow\) Green's function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdc052b754ed41227910a2e963346f55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getMagnetization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the exp. value for the magnetization </p>
<p>The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int n)</a> and <a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8" title="see createPolesG_Up(int iteration). This is the spin-  version. ">createPolesG_Down(int n)</a>. The magnetization is calculated as \( \avg{m} = \avg{n_\uparrow} - \avg{\downarrow}\) </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a24986007a997c14f3f5317d53d6694e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nrg::NRG::getMaxHilbertSpaceDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the maximum allowed size of the HilberSpace. See <a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308" title="marks all eigenstates above a cut-off energy  as discarded. ">truncateStates(int n)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>max dimension of HilbertSpace </dd></dl>

</div>
</div>
<a class="anchor" id="a16d861665f0ac0e3c0bf356cc08cf3b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nrg::NRG::getMaxIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the number of <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iterations to be performed.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iterations </dd></dl>

</div>
</div>
<a class="anchor" id="a6d28e59b88fd98e74ff30b0eed34a564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getOccupation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the exp. value for electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int n)</a> and <a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8" title="see createPolesG_Up(int iteration). This is the spin-  version. ">createPolesG_Down(int n)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a048acdb83a27cfe673a82a6a53897f2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getOccupationDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the exp. value for spin- \(\downarrow\) electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a4ea85b0f075bafa8d67a7a1a5ac670e8" title="see createPolesG_Up(int iteration). This is the spin-  version. ">createPolesG_Down(int n)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0f798bf64f770334c1b62587cdf59663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getOccupationUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the exp. value for spin- \(\uparrow\) electrons on the impurity. The actual calculation is performed in <a class="el" href="classnrg_1_1_n_r_g.html#a3e17ab2a4393f21a6863b714e3dc0e85" title="calculates delta peaks for the spin-  impurity Green&#39;s function. ">createPolesG_Up(int n)</a>. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acc519743d6cdc9924f75329386dd6d00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getSelfEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>SUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>SDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the impurity selfenergy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">SUp</td><td>reference to spin- \(\uparrow\) self energy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SDown</td><td>reference to spin- \(\downarrow\) self energy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7beee407b6defe0184e8a2244efa1716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::getSelfEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmath_1_1_c_function.html">math::CFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the impurity selfenergy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>reference to spin- \(\uparrow\) self energy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d2da4871033be406050c5af5d7cd2dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getTemperature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieves the system temperature T </p>
<dl class="section return"><dt>Returns</dt><dd>system temperature T </dd></dl>

</div>
</div>
<a class="anchor" id="ae076986d428d7d680c467a646dfb820a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nrg::NRG::getU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieves the strength of the on-site impurity interaction U </p>
<dl class="section return"><dt>Returns</dt><dd>on-site impurity interaction U </dd></dl>

</div>
</div>
<a class="anchor" id="a2761a143fc6a1cf385b91ad95453409a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepares the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> instance for the iterative diagonalization. </p>
<p>The function performs the following steps: </p>
<h4>Initialization</h4>
<ul>
<li>If the max. iterations have not been set, chooses them automatically based on the system temperature T.</li>
<li>Checks whether enough <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration will be performed for the given temperature T.</li>
<li>Calls the <a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> to prepare a chain of the appropriate length,</li>
<li>Sets the temperature T in the broadeners and initializes them.</li>
<li>Calls <a class="el" href="classnrg_1_1_n_r_g.html#a360c9dc565beed2c2e741eceb7696036" title="initializes the impurity Hamiltonian . ">setupInitialState()</a> to initialize the impurity Hamiltonian \(H_0\). </li>
</ul>

</div>
</div>
<a class="anchor" id="a99ae89acb88e93156c845c5ecea4612e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateChainOperatorElementsDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classnrg_1_1_n_r_g.html#a38d8a5fd44271bd1a246c65b86ee7f82" title="calculates the chain matrix elements for spin-  for a given iteration. ">propagateChainOperatorElementsUp(int iteration)</a>. This is the spin- \(\downarrow\) version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d8a5fd44271bd1a246c65b86ee7f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateChainOperatorElementsUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the chain matrix elements for spin- \(\uparrow\) for a given iteration. </p>
<p>Assuming that we have diagonalised a Wilson chain of length \(m\) and that the eigenstates are given by \(|\mathbf r;m\rangle\) we construct a product basis for the Wilson chain of length \(m+1\) by</p>
<p>\( \begin{equation} |(\mathbf r,\alpha_{m+1});m+1\rangle = |\mathbf r; m\rangle \otimes |\alpha_{m+1}\rangle \end{equation} \)</p>
<p>where \(|\alpha_{m+1}\rangle\) are the eigenstates of the decoupled site \(|\alpha_{m+1}\rangle=\{ |\rangle,|\uparrow\rangle,|\downarrow\rangle,| \uparrow \downarrow \rangle \}\). The matrix elements of the Hamiltonian for the Wilson chain of length \(m+1\) for this product basis are given by</p>
<p>\( \begin{align} \langle(\mathbf r&#39;,\alpha&#39;_{m+1}); m+1| &amp;H_{m+1} |(\mathbf r,\alpha_{m+1}); m+1\rangle = \Lambda^{1/2} E_{\mathbf r,m} \delta_{\mathbf r \mathbf r&#39;} \delta_{\alpha \alpha&#39;} \nonumber \\ &amp;+\left( \langle \mathbf r&#39;; m | f^\dagger_{m\sigma} | \mathbf r;m \rangle \langle \alpha&#39;| f_{m+1\alpha} |\alpha \rangle + \langle \mathbf r&#39;; m | f_{m\sigma} |\mathbf r;m\rangle \langle\alpha&#39;| f^\dagger_{m+1\alpha} |\alpha\rangle\right). \end{align} \)</p>
<p>It is precisely the matrix elements \( \langle \mathbf r&#39;; m | f^\dagger_{m\uparrow} | \mathbf r;m \rangle \), which are calculated in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c4975dc830c8f9c38c66dc0e877cd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateLocalMatrixElementDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classnrg_1_1_n_r_g.html#a3a868ffea9b163edd3d067d63952d2ad" title="calculates the local impurity matrix elements or spin-  for a given iteration. ">propagateLocalMatrixElementUp(int iteration)</a>. This is the spin- \(\downarrow\) version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4f818bc65b105af60350aba50367b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateLocalMatrixElementDown2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classnrg_1_1_n_r_g.html#a057fbf412fc125417bf8788ab0a6ef9b" title="calculates other local impurity matrix elements or spin-  for a given iteration. ">propagateLocalMatrixElementUp2(int iteration)</a>. This is the spin- \(\downarrow\) version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a868ffea9b163edd3d067d63952d2ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateLocalMatrixElementUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the local impurity matrix elements or spin- \(\uparrow\) for a given iteration. </p>
<p>Lehmann resolving the impurity spectral function one obtains</p>
<p>\( \begin{equation} A_\sigma(\omega) = \sum_{a,b} \bra{b} c_{d\sigma}\ket{a} \frac{\exp{\left[ -\beta E_a \right]}}{Z} \bra{a}c_{d\sigma}^\dagger\ket{b} \delta(\omega + E_a - E_b) \end{equation} \)</p>
<p>where $Z$ is the total partition function $Z =  {[ - E_a ]}$, ${a}$ and ${b}$ are a complete set of states and $E_a$ is the eigenenergy of state ${a}$. We see that the Lehmann representation gathers the necessary information to construct the spectrum from knowledge of certain matrix elements encoding hopping processes between the impurity and the conduction electron band. It is precisely these matrix elements \( \langle \mathbf r&#39;; m | c^\dagger_{\uparrow} | \mathbf r;m \rangle \delta_{\alpha&#39; \alpha} \) which are calculated in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057fbf412fc125417bf8788ab0a6ef9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::propagateLocalMatrixElementUp2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates other local impurity matrix elements or spin- \(\uparrow\) for a given iteration. </p>
<p>Bulla et al. first showed that it is possible to write the self-energy as the ratio of two correlation functions, both of which can be calculated directly within the <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a>. An equation of motion technique is used to show that the self-energy is given by,</p>
<p>\( \begin{equation} \Sigma_\sigma(\omega) = U \frac{F_{\sigma}(\omega)}{G_{\sigma}(\omega)} \end{equation} \)</p>
<p>where $G_{}()$ is the impurity Green's function defined as</p>
<p>\( \begin{equation} G_{\sigma}(\omega) = -i \int_{-\infty}^\infty dt~e^{ i \omega t } \Theta(t) \avg{ \left\{ f_{\sigma}(t), f_{\sigma}^\dagger \right\} } \end{equation} \)</p>
<p>and $F_{}()$ is an auxiliary correlation function given by</p>
<p>\( \begin{equation} F_{\sigma}(\omega) = -i \int_{-\infty}^\infty dt e^{ i \omega t } \Theta(t) \avg{ \left\{ \left( f_{\bar{\sigma}}^\dagger f_{\bar{\sigma}} f_{\sigma}\right)(t), f_{\sigma}^\dagger \right\} } \end{equation} \)</p>
<p>The imaginary parts of $F_{}()$ and $G_{}()$ are calculated from <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> data using the Lehman sum within the full density matrix approach, with the poles of the spectrum broadened as above. The real parts are then obtained by Kramers-Kronig transform. Discretization artifacts cancel to some extent by dividing the two quantities. This produces a rather smooth self-energy, which in term can be used to calculate an improved spectrum for the impurity. Z-averaging can also be used to further increase accuracy and resolution.</p>
<p>It is precisely these matrix elements \( \langle \mathbf r&#39;; m | c^\dagger_{\downarrow} c^\phantom{\dagger}_{\downarrow} c^\dagger_{\uparrow} | \mathbf r;m \rangle \delta_{\alpha&#39; \alpha} \) which are calculated in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1a3acc6323287e027b8bef2dd997143"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setClusterEnergy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>clusterEnergy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the cluster energy to the indicated value. see <a class="el" href="classnrg_1_1_n_r_g.html#af4e0aac1a11a4901db957b979c43b9ce" title="returns the cluster energy. ">getClusterEnergy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterEnergy</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebf915bc58252a82cf75bc9a0a66671b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setEnergyCutOff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>energyCutOff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the high energy cut-off for state truncation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clusterEnergy</td><td>new high-energy cut-off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c8461747f2e58ace9b14e6966bb6800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setEpsF </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the on-site impurity energy \(\epsilon_f\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsF</td><td>on-site energy \(\epsilon_f\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d674168a503bb87c5f96facffeed312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setMaxHilbertSpaceDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxHSdimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the maximum allowed size of the HilberSpace. See <a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308" title="marks all eigenstates above a cut-off energy  as discarded. ">truncateStates(int n)</a>. </p>
<p>It is advisable to set this number to a large value (so that it does not get in the way) and let the energy cut-off( see <a class="el" href="classnrg_1_1_n_r_g.html#aebf915bc58252a82cf75bc9a0a66671b" title="sets the high energy cut-off for state truncation ">setEnergyCutOff(double energyCutOff)</a> ) do the truncation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxHSdimension</td><td>max. dimension of the HilbertSpace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a986c109b4276b419f4e8de09b0295e3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setMaxIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the number of <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iterations to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIterations</td><td># of <a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4a18a1d48d935fe2f226fe6538a8814"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setTemperature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the system temperature T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>system temperature T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49aa5d54ee31cd893c461bcd620a8e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setU </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the strength of the on-site impurity interaction U </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>on-site impurity interaction U </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61869162fe17cdf5cf34857b9abd132e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setupHamiltonian </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterates over all possible quantum number Q and Sz for iteration N and constructs the Hamiltonian for the corresponding <a class="el" href="classnrg_1_1_hilbert_sub_space.html" title="HilbertSubSpace: Hilbert subspace for charge quantum number Q and spin Sz. This class contains the ei...">HilbertSubSpace</a>. </p>
<p>For a given <a class="el" href="classnrg_1_1_hilbert_sub_space.html" title="HilbertSubSpace: Hilbert subspace for charge quantum number Q and spin Sz. This class contains the ei...">HilbertSubSpace</a> (HSS) in iteration N the function looks up the appropriate HSSs (up to 4) of iteration N-1 and uses the chain matrix elements to construct the Hamiltonian for the HSS in iteration N. Then the Hamiltonian is diagonalized using a call to Lapack's <a href="http://www.netlib.org/lapack/explore-3.1.1-html/dsyev.f.html">dsyev</a> Lapack replaces the Hamiltonian m_H in the HSS by the unitary transformation that diagonalized it and places and sorts the eigenvalues (energies) into the HSS object as well. The function discards the chain matrix elements of iteration N-1, which are no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a360c9dc565beed2c2e741eceb7696036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::setupInitialState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes the impurity Hamiltonian \(H_0\). </p>
<p>This function creates the first 4 <a class="el" href="classnrg_1_1_hilbert_sub_space.html" title="HilbertSubSpace: Hilbert subspace for charge quantum number Q and spin Sz. This class contains the ei...">HilbertSubSpace</a> instances for the chain consisting only of the impurity ( \( \{ |\rangle,|\uparrow\rangle,|\downarrow\rangle,| \uparrow \downarrow \rangle \}\) ). It determines the eigenenergies and both the local impurity and the chain matrix elements. </p>

</div>
</div>
<a class="anchor" id="a54a2a7395b2f9a5b6884b8c44f969d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::solve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves the impurity problem. </p>
<p>First, the function queries the <a class="el" href="classnrg_1_1_chain_provider.html">ChainProvider</a> whether the provided chain is symmetric with respect to the Sz quantum number. If so, it suffices to calculate all matrix elements and correlator for spin- \(\uparrow\) only.</p>
<p>The algorithm moves along the Wilson chain iteratively in a forward-backward- forward pattern.</p>
<h4>Step 1 - Forward run: Iterative diagonalization</h4>
<p>In the first forward run, the Hamiltonian is iteratively constructed and diagonalized (using <a class="el" href="classnrg_1_1_n_r_g.html#a61869162fe17cdf5cf34857b9abd132e" title="iterates over all possible quantum number Q and Sz for iteration N and constructs the Hamiltonian for...">setupHamiltonian(int n)</a> ). Chain matrix elements are calculated along the way as needed. Once the highest eigenenergy of the chain exceeds the predefined threshold value, the truncation sets in (see <a class="el" href="classnrg_1_1_n_r_g.html#a430ab28bf443456a5f61e488305eb308" title="marks all eigenstates above a cut-off energy  as discarded. ">truncateStates(int iteration)</a> ) and only the kept states are used to construct the HilbertSpace of the next iteration.</p>
<h4>Step 2 - Backward run: Reduced density matrix</h4>
<p>In a second step, buildDM() is called, which performs a backward run starting from the last iteration and calculates the reduced density matrix for the different iterations.</p>
<h4>Step 3 - Forward run: Calculation of Correlators</h4>
<p>In a third step, a forward run is performed which uses the reduced density matrix to calculate impurity matrix elements. The matrices are propagated from iteration to iteration and used to calculate an approximate Lehmann representation of the impurity Green's function and a another correlation function which is needed for the self-energy trick.</p>
<p>Finally, the discrete set of delta peaks for each correlator is broadened to get continous functions (see <a class="el" href="classnrg_1_1_broadener.html">Broadener</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">silent</td><td>if true, silences the impurity solver (useful for DMFT) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9d7e07864134a128a4a0628531ecdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::solve_symmetric_SZ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <a class="el" href="classnrg_1_1_n_r_g.html#a54a2a7395b2f9a5b6884b8c44f969d13" title="solves the impurity problem. ">solve(bool silent)</a> for a Wilson chain with Sz symmetry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silent</td><td>if true, silences the impurity solver (useful for DMFT) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a430ab28bf443456a5f61e488305eb308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrg::NRG::truncateStates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iteration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>marks all eigenstates above a cut-off energy \(E_c\) as discarded. </p>
<p>The Hilbertspace grows exponentially with the length of the Wilson chain. Therefore the eigenstates have to be truncated above an energy cutoff (see void <a class="el" href="classnrg_1_1_n_r_g.html#aebf915bc58252a82cf75bc9a0a66671b" title="sets the high energy cut-off for state truncation ">setEnergyCutOff(double energyCutOff)</a> ). Only the "kept" states in iteration N-1 with an energy smaller than the cut-off are used to construct the Hilbertspace for iteration N. A separation of energy scales is achieved by the logarithmic discretization of the energy band and justifies the truncation: States with a high energy in iteration N-1 cannot affect the structure of the low-energy states in iteration N.</p>
<p>Special attention has to be paid to the role of symmetries. Symmetries create degeneracies in the spectrum of eigenstates. Due to numerical noise these states can energetically drift apart by tiny amounts. It is generally not a good idea to cut-off within a multiplet. It is ensured that no cut is made in between two energy levels less than a certain energy difference apart (see void <a class="el" href="classnrg_1_1_n_r_g.html#ae1a3acc6323287e027b8bef2dd997143" title="sets the cluster energy to the indicated value. see getClusterEnergy(). ">setClusterEnergy(double clusterEnergy)</a> ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration</td><td><a class="el" href="classnrg_1_1_n_r_g.html" title="Density matrix implementation of the numerical renormalization group. ">NRG</a> iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/chris/Documents/Development/Release/nanostructures/nrg/<a class="el" href="nrg_8h_source.html">nrg.h</a></li>
<li>/Users/chris/Documents/Development/Release/nanostructures/nrg/nrg.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 3 2014 09:39:47 for NanoStructures by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</div><!-- backplane -->
</div><!-- container -->
</body>
</html>
